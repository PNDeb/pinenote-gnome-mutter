From: Carlos Garnacho <carlosg@gnome.org>
Date: Tue, 14 Apr 2020 13:40:52 +0200
Subject: x11: Don't stall on write_async()

If a write_async() comes up while we are flushing on the background,
the task will be queued, but not deemed a reason on itself to keep
flushing (and finish the task) after a property delete event.

To fix this, do not ever queue up write_async tasks (this leaves
priv->pending_task only used for flush(), so the "flush to end"
behavior in the background is consistent). We only start a
background flush if there's reasons to do it, but the tasks are
immediately finished.

All data will still be ensured to be transfered on flush/close,
this makes the caller in this situation still able to reach to it.

https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1198

(cherry picked from commit 655a783891ac38c01834cb6d9631aa5834666892)

Origin: upstream, 3.36.2
---
 src/x11/meta-x11-selection-output-stream.c | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/src/x11/meta-x11-selection-output-stream.c b/src/x11/meta-x11-selection-output-stream.c
index bc13dbc..3ba05ab 100644
--- a/src/x11/meta-x11-selection-output-stream.c
+++ b/src/x11/meta-x11-selection-output-stream.c
@@ -384,16 +384,11 @@ meta_x11_selection_output_stream_write_async (GOutputStream       *output_stream
       g_object_unref (task);
       return;
     }
-  else if (!meta_x11_selection_output_stream_can_flush (stream))
-    {
-      g_assert (priv->pending_task == NULL);
-      priv->pending_task = task;
-      g_task_set_task_data (task, GSIZE_TO_POINTER (count), NULL);
-      return;
-    }
   else
     {
-      meta_x11_selection_output_stream_perform_flush (stream);
+      if (meta_x11_selection_output_stream_can_flush (stream))
+        meta_x11_selection_output_stream_perform_flush (stream);
+
       g_task_return_int (task, count);
       g_object_unref (task);
       return;
